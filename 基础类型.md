## 基础类型



#### 类型断言

通过类型断言这种方式可以告诉编译器，“相信我，我知道自己在干什么”。 类型断言好比其它语言里的类型转换，但是不进行特殊的数据检查和解构。 它没有运行时的影响，只是在编译阶段起作用。

有两种方式，一种是尖括号的形式，<类型> xxx,  另一种是as的形式 (xxx as string)



```js
function getLength (n: string | number) {
  if ((<string>x).length) {
      return (x as string).length;
      } else {
        return x.toString.length;
      }
}
```



#### 类型推断



### 接口 interface



#### 函数类型

接口除了可以描述普通的对象之外，也可以描述函数类型

```js
interface SearchFun {
  (source: string, str: string): boolean
}
// 定义一个函数，该类型就是上面定义的接口
let search: SearchFun = function (source: string, str: string): boolean {
  return source.search(str) > -1;
}

```



#### 类类型

总结： 接口和接口之间叫继承， 类和接口之间叫实现

```typescript

interface Fly {
    flys(): void
}

class TheFly implements Fly {
    flys() {
        console.log('1');
    }
    adb () {
        
    }
}
// 2
interface Flys {
  sendFly():void
}
class Person implements Fly, Flys {
  sendFly () {
    
  }
  flys() {
        console.log('1');
  }
}
// 定义一个接口，可以继承多个接口
interface MoreFly extends Fly, Flys {
  
}

// 
```



## 类

类和类之间如果要有继承关系，需要使用extends关键字

子类中可以调用父类中的构造函数，使用的是super关键字

子类中可以重写父类中的方法

```typescript
// TS 中类的定义和使用

class Person {
  name: string
  age: number
  constructor (age: number = 12) {
    this.age = age;
    this.name = '1';
  }
  sayHi (name: string) {
    console.log('1')
  }
}
class Students extends Person {
  constructor (age: number) {
    // 调用父类中的构造函数
    super(age)
  }
  // 可以调用父类中的方法
  sayHi () {
      super.sayHi('qwe');
  }
}
```



### 多态

父类型的引用指向了子类型的对象

不同类型的对象针对相同的方法，产生了不同的行为



### 类中成员的修饰符

public 默认的访问修饰符，代表公共的，任何位置都可以访问类中的成员



private修饰符 私有属性，只能在类中使用，不能在类外面使用，特别是子类中也是无法使用的



protected修饰符，外部是不能使用的，子类中可以使用



readonly 修饰符，对类中的属性进行修饰，但是，不能在外部修改了；但是，构造函数中，可以对只读的属性进行修改

一旦使用readonly进行修饰之后，就有了一个age属性成员

下面的例子，修饰器还可以用在构造函数的参数上

```js
class Person {
  name: string
  constructor (readonly age: number = 12) {
    this.age = age;
    this.name = '1';
  }
  sayHi (name: string) {
    console.log('1')
  }
}
```



### 存取器







## 函数



## 泛型



